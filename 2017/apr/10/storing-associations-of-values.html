<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from blog.nut/2017/apr/10/storing-associations-of-values by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 15 Oct 2020 14:56:17 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <script>var _gaq = _gaq || []; _gaq.push(['_setDomainName', location.hostname]);</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1">
    <title>
Storing associations of values -       Félix “passcod” Saparelli - Blog
    </title>
    <link rel="alternate" href="../../../feed">
    <link rel="stylesheet" href="../../../assets/1.3.3/style.css">
  </head>

  <body>
    <div class="raised">
      <header class="root">
        <h1><a href="../../../index.html">Félix Saparelli</a></h1>
        <p class="sidelong"><a rel="me" href="https://passcod.name/">(about me)</a></p>
        <p class="subtitle">a.k.a. passcod<a href="https://blog.passcod.name/trademark">™</a></p>
      </header>
      <main>
        <article class="h-entry e-content">
  <header>
    <h1 class="p-name">Storing associations of values</h1>

  
    <p>Posted on <a href="storing-associations-of-values.html" class="u-url"><date datetime="2017-04-10T13:09:28.000Z" title="2017-04-10T13:09:28.000Z" class="dt-published">Apr 10 ‘17</date></a></p>
  

  
    <p>This
      
      <a href="../../../tag/post.html" rel="main tag" class="p-category">post</a>
      is also tagged as
        <a href="../../../tag/datastructure.html" rel="tag" class="p-category">datastructure</a>, <a href="../../../tag/hyperium.html" rel="tag" class="p-category">hyperium</a>
      
    </p>
  

  
  </header>

  <p>This is a description of an algorithm for a particular pattern I’ve encountered
several times throughout my programming and systems designing experience. It’s
fairly simple, but nevertheless:</p>
<p>The pattern is this: you have a set of values, let’s call them <em>vertices</em>, and
you want to associate them together, let’s call that association an <em>edge</em>,
such that later on, given a single <em>vertex</em> you are able to retrieve the <em>edge</em>
and all <em>vertices</em> it contains.</p>
<p>The prerequisites are a hash function, let’s call it <code>H()</code>, and a key-value
store with two functions: <code>KV.get(key) → value</code> and <code>KV.set(key, value)</code>.</p>
<p>To store the <em>edge</em> containing the <em>vertices</em> <code>v1</code>, <code>v2</code>, <code>v3</code>, you:</p>
<ol>
<li>Compute the hashes of <em>vertices</em>:
<ul>
<li><code>h1 = H(v1)</code></li>
<li><code>h2 = H(v2)</code></li>
<li><code>h3 = H(v3)</code></li>
</ul>
</li>
<li>Concatenate these hashes and compute the hash of that:
<ul>
<li><code>h_all = H(v1 . v2 . v3)</code></li>
</ul>
</li>
<li>Store the <em>vertices</em> under that common key:
<ul>
<li><code>KV.set(h_all, ntuple&lt;v1, v2, v3&gt;)</code></li>
</ul>
</li>
<li>Store the common key under the hashes of <em>vertices</em>:
<ul>
<li><code>KV.set(h1, h_all)</code></li>
<li><code>KV.set(h2, h_all)</code></li>
<li><code>KV.set(h3, h_all)</code></li>
</ul>
</li>
</ol>
<p>Then, to retrieve the <em>edge</em> given a <em>vertex</em> <code>v</code>, you:</p>
<ol>
<li>Compute the hash of the <em>vertex</em>:
<ul>
<li><code>h = H(v)</code></li>
</ul>
</li>
<li>Retrieve the common key:
<ul>
<li><code>h_all = KV.get(h)</code></li>
</ul>
</li>
<li>Retrieve the <em>edge</em>:
<ul>
<li><code>ntuple&lt;v…&gt; = KV.get(h_all)</code></li>
</ul>
</li>
</ol>
<p>That’s it.</p>
<p>Time requirements are thus <code>(n + 1) * (H time + KV.set time)</code> for <strong>set</strong> and
<code>2 * KV.get + 1 * H</code> for <strong>get</strong>, where <code>n</code> is the number of <em>vertices</em> to be
associated.</p>
<p>And space requirements are <code>(n + 1)</code> KV entries, one storing exactly only the
combined size of vertices, and <code>n</code> storing exactly only a fixed-size hash.</p>
<p>The datastructure described can be called a “Hypermap”, and is a
non-overlapping, non-directed, non-multi Hypergraph. An overlapping Hypergraph
(but still non-directed and non-multi) can be constructed trivially from this.
A Hypermap is also a generalisation of a <a href="https://en.wikipedia.org/wiki/Bimap">Bimap</a>, which can be described as a
Hypermap where <em>edges</em> only contain exactly two <em>vertices</em>.</p>


  <footer>
  
    <p>Travel back to the <a rel="prev" href="monthly-update.html" title="Style As you’ve probably noticed, I have refreshed the style of this website, as well as the root of my domain. Goodbye monospaced font for everything! The font is…">previous</a> article</p>
  

  
    <p>Skip forward to the <a rel="next" href="../../may/10/monthly-update.html" title="I only started writing this update on the 28th April, so it might be a little shorter than usual. Birthday May 4th was my birthday, which I learned a few years ago coincides with the (unofficial) Star Wars Day (“May the Fourth be…">next</a> one</p>
  

    <p>Praise, thoughts, criticism? <a href="https://twitter.com/passcod">@passcod</a> or <a href="mailto:felix@passcod.name">felix@passcod.name</a></p>

  
  </footer>
</article>

      </main>
    </div>
    <footer class="root">
      <p>
        <a rel="alternate" href="../../../feed">Feed</a>.
        © 2008–2020.
        Content licensed under <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
      </p>
    </footer>

    <button class="flip" title="Turn the lights off.">day</button>
    <script async src="../../../assets/1.3.3/circadian.js"></script>
    <script async src="../../../assets/1.3.3/prism.js"></script>

    <link rel="stylesheet" href="../../../assets/1.3.3/fonts.css">
    <link rel="stylesheet" href="../../../assets/1.3.3/prism.css">
  </body>

<!-- Mirrored from blog.nut/2017/apr/10/storing-associations-of-values by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 15 Oct 2020 14:56:17 GMT -->
</html>
